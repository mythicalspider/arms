#!/bin/bash

# requires coproc, stdbuf, mysql

# Derived from: BASIC MYSQL SESSION IMPLEMENTATION FOR BASH (by Norman Geist 2015)
# Expanded by: Jeremy Gurr 2017

#  # Example usage
#  #define timeout for read command, in case of server error etc.
#  export MYSQL_READ_TIMEOUT=10
#  
#  # Connect to db and get $HANDLE
#  mysql_connect -u mydbuser -d mydb -H mydbserver
#  
#  #query db and get $DATA
#  mysql_query $HANDLE "SELECT dt_whatever from tbl_lol WHERE dt_rofl=10"
#  
#  #close connection
#  mysql_close $HANDLE
#  
#  
#  $DATA[0] = affected rows/number of sets;
#  $DATA[1] = number of key=>values pairs following;
#  $DATA[2] = key1;
#  $DATA[3] = value1;
#        [...]
#  $DATA[n-1] = keyn;
#  $DATA[n]   = valuen;
#  
#  # two column query loop example
#  
#  fields=2
#  for ((i=2; $i<$((${DATA[0]}*${DATA[1]}*$fields)); i+=$((${DATA[1]}*$fields))))
#  do
#      field1key   = ${DATA[$i]};   #this is "dt_id"
#      field1value = ${DATA[$i+1]}; #this is the value for dt_id
#      field2key   = ${DATA[$i+2]}; #this is "dt_name"
#      field2value = ${DATA[$i+3]}; #this is the value  for dt_name
#  done

# set a default here
export MYSQL_READ_TIMEOUT=10

#args handle query
function mysql_check {
  local handle
  handle=(${1//_/ })
  #has right structure && is still running && we opened it?
  if [[ ${#handle[*]} == 3 ]] && ps -p ${handle[2]} 2>> /dev/null >> /dev/null && { echo "" >&${handle[1]}; } 2> /dev/null; then
    return 0
  fi
  return 1
}

# open mysql connection
# usage: user="myuser" pass="mypass" host="myhost" db="mydb" mysql_connection
#   host and pass are optional
# returns $HANDLE
function mysql_connect {
  local argv argc HANDLEID i
  #prepare args
  argv=($*)
  argc=${#argv[*]}

  host="${host:-localhost}"
  if [ "$pass" ]; then
    pass="-p $pass"
  fi

  if [[ ${#user} -lt 1 || ${#db} -lt 1 ]]; then
    echo "ERROR: Options -u user and -d db are required!"
    return 1;
  fi

  # init connection and channels
  # we do it in XML cause otherwise we can't detect the end of data and so would need a read timeout O_o
  HANDLEID="MYSQL$RANDOM"
  eval "coproc $HANDLEID { stdbuf -oL mysql -u $user $pass -h $host -D $db --force --unbuffered --xml -vvv 2>&1; }" 2> /dev/null
  HANDLE=$(eval 'echo ${'${HANDLEID}'[0]}_${'${HANDLEID}'[1]}_${'${HANDLEID}'_PID}')
  if mysql_check $HANDLE; then
    export HANDLE
    return 0
  else
    echo "ERROR: Connection failed to $user@$host->DB:$db!"
    return 1
  fi
}

# usage: HANDLE={handle} mysql_query {query}
# return: $DATA[0] = affected rows/number of sets;
#         $DATA[1] = key=>values pairs following
#         $DATA[2] = key1; DATA[3] = val1
#         $DATA[4] = key2; DATA[5] = val2 (depending on number of columns, rows)
function mysql_query {
  local handle query affected line results_open row_open cols key val
  if ! mysql_check $HANDLE; then
    echo "ERROR: Connection not open!"
    return 1
  fi
  handle=(${HANDLE//_/ })

  # delimit query; otherwise we block forever/timeout
  query=$2
  if [[ ! "$query" =~ \;\$ ]]; then
    query="$query;"
  fi
  #send query
  echo "$query" >&${handle[1]}

  #get output
  DATA=();
  DATA[0]=0
  DATA[1]=0
  results_open=0
  row_open=0
  cols=0
  while read -t $MYSQL_READ_TIMEOUT -ru ${handle[0]} line
  do
    # WAS ERROR?
    if [[ "$line" == *"ERROR"* ]]; then
      echo "$line"
      return 1
    # WAS INSERT/UPDATE?
    elif [[ "$line" == *"Query OK"* ]]; then
      affected=$([[ "$line" =~ Query\ OK\,\ ([0-9]+)\ rows?\ affected ]] && echo ${BASH_REMATCH[1]})
      DATA[0]=$affected
      export DATA
      return 0
    fi

    # BEGIN FETCHING RESULTS
    if [[ $line =~ \<resultset ]]; then
      results_open=1
    fi

    #RESULTS
    if [[ $results_open == 1 ]]; then
      if [[ $line =~ \<row ]]; then
        row_open=1
        cols=0
      elif [[ $line =~ \<field && $row_open == 1 ]]; then
        key=$([[ "$line" =~ name\=\"([^\"]+)\" ]] && echo ${BASH_REMATCH[1]})
        val=$([[ "$line" =~ \>(.*)\<\/ ]] && echo ${BASH_REMATCH[1]} || echo "NULL")
        DATA[${#DATA[*]}]=$key
        DATA[${#DATA[*]}]=$val
        cols=$[$cols+1]
      elif [[ $line =~ \<\/row ]]; then
        row_open=0
        DATA[0]=$[${DATA[0]}+1]
        DATA[1]=$cols
      fi
    fi

    #END OF RESULTS
    if [[ $line =~ \<\/resultset ]]; then
      export DATA
      return 0
    fi
  done
  #we can only get here
  #if read times out O_o
  echo "$FUNCNAME: Read timed out!"
  return 1
}

# usage: HANDLE={handle} mysql_close
function mysql_close {
  local handle
  if ! mysql_check $1; then
    echo "ERROR: Connection not open!"
    return 1
  fi
  handle=(${1//_/ })
  echo "exit;" >&${handle[1]}

  if ! mysql_check $1; then
    return 0
  else
    echo "ERROR: Couldn't close connection!"
    return 1
  fi
}

