#!/bin/bash

# setup used by most other script libraries in lib folder
# soure this before other libraries

shopt -s expand_aliases      # make sure aliases are expanded even for non-interactive scripts
set -u                       # error when a script attempts to use an unset variable

alias err='echo -e >&2 "ERROR:"'
alias out='[ $debug -gt 0 ] && printf "[%${debug_digits}d] " $debug && echo -e'
alias out_short='[ $debug -gt 0 ] && echo -e'
alias deep_out='[ $debug -gt 10 ] && printf "[%${debug_digits}d] " $((debug-10)) && echo -e'
alias deep_out_short='[ $debug -gt 10 ] && echo -e'
alias super_out='[ $debug -gt 100 ] && printf "[%${debug_digits}d] " $((debug-100)) && echo -e'
alias super_out_short='[ $debug -gt 100 ] && echo -e'

# dive and undive should be used immediately in front of a command or at the beginning of a function with a local debug
#   or it will shift the debug level for all code that follows
alias dive='debug=$((debug-1))'
alias undive='debug=$((debug+1))'
alias deep_dive='debug=$((debug-10))'
alias deep_undive='debug=$((debug+10))'
alias super_dive='debug=$((debug-100))'
alias super_undive='debug=$((debug+100))'

# exception handling
# usage example:
#   function do_stuff() {
#     try
#       open_connection || fail
#       for ((i = 0; i < 10; i++)); do 
#         stuff || fail
#       done
#       maybe_break
#      
#       more_stuff
#     end_try
#     close_connection
#     handle_return
#   }

# default debug level is 1. Set to 0 for no output except for errors.
export debug=${debug:-1}
export debug_digits=${#debug}
# only run this once within a function definition
alias try='local debug=$((debug-1)) return_value=0; while true; do'
alias end_try='break; done; debug=$((debug+1))'

alias fail='{ return_value=1; break; }'

# should be placed after any loop inside of an exception catching block
alias maybe_break='[ $return_value == 0 ] || break'
alias maybe_exit='[ $return_value == 0 ] || exit 1'

# should be at the end of every function which contains a try / end_try block
alias handle_return='return $return_value'
alias handle_exit='exit $return_value'

# newline
newline=$'\n'
# usage: echo " blah   " | trim
trim() {
  sed -e 's/^[[:space:]]*\(.*\)[[:space:]]*$/\1/'
}

true                      # make sure we return successfully so calling script can properly move forward

