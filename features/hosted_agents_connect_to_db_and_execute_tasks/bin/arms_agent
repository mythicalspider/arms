#!/bin/bash

if [ ! -d lib ]; then
  echo "Missing lib folder. Make sure you run this script from the directory where it is, and that the lib folder is there with the required scripts."
  exit 1
fi

agent_tmp=/tmp/arms_agent
rm -rf $agent_tmp &>/dev/null
mkdir $agent_tmp || exit 1
cd $agent_tmp || exit 1

source lib/* || exit 1

lock arms &>/dev/null || (echo "arms agent is already running"; exit 1)

dbexecute() {
mysql_query "$1" || return 1
}

if [ ! -f arms_agent.config ]; then
  echo "Missing arms_agent.config. It must exist in the current directory."
  exit 1
fi

source arms_agent.config
requireVar host_id db_host db_user db_pass || {
  echo "Make sure that you have defined this variable in your arms_agent.config file"
  exit 1
}

# optional variables which may be set in arms_agent.config

# max_processes : maximum number of processes to run at once

initialize_process_tracking ${max_processes:-4}

establish_connection() {
  host=$db_host user=$db_user pass=$db_pass mysql_connect || return 1
}

establish_connection

# usage: insert_into_output_table {file_name containing content}
# if file doesn't exist, returns true but no output_id
# returns 1 if anything fails
# sets output_id to inserted id if record was successfully inserted
insert_into_output_table() {
local file_name=$1
local content id
local returnValue=0
unset output_id
while true; do
  if [ -f $file_name ]; then
    eval "content=\$(<$file_name)"
    content=${content//'/\\'}

    dbexecute "
      insert into output set
        creation_time=now()
        , content='$content'
      " || (echo "couldn't insert record into output table."; fail)

    dbfetch_single_value "select last_insert_id()" || fail
    output_id=$r

  fi
  break
done

handleReturn
}

main_loop() {
local returnValue=0
while true; do
  while true; do 
    if grab_completed_process; then
      cd job_${job_id} || fail

      local job_status=failed
      [ -f succeeded ] && job_status=succeeded

      insert_into_output_table output || fail
      local oid=output_id
      insert_into_output_table error || fail
      local eid=output_id

      dbexecute "
        insert into task_status_change set 
          task_request_id=$(<task_request_id)
          , output_id=$oid
          , error_id=$eid
          , event_time=now()
          , new_status='done'
          , result='$job_status'
        " || (echo "failed to insert task change record."; fail)

      cd .. || fail
      rm -rf job_${job_id} 
      
      continue # we need to keep pulling completed processes out until they are gone
    fi
    break
  done

  if can_launch_more_processes; then
    # grab a task to do
    dbexecute "
      select tr.task_request_id, s.content, tr.parameters 
      from task_request_not_done trnd 
      inner join task_request tr using (task_request_id)
      inner join script s using (script_id)
      left join task_status_change tsc on trnd.task_request_id = tsc.task_request_id
      where host_id = $host_id
      and tsc.task_request_id is null
      limit 1
      " || (echo "failed to fetch new tasks."; fail)

    if more_rows_to_read; then
      grab_row task_request_id script_content script_parameters || (echo "failed to get row from array."; fail)
      dbexecute "
      insert into task_status_change set
        task_request_id = $task_request_id
        , event_time = now()
        , new_status = 'started'
      " || (echo "failed to update task status."; fail)

      mkdir job_${job_id} || fail
      cd job_${job_id} || fail
      echo "$task_request_id" >task_request_id || fail
      echo "$script_content" >request || fail
      sh request $script_parameters >output 2>error </dev/null &
      track_process || fail
      cd .. || fail
    fi
  fi

  # there's nothing to do right now, let's rest a bit before trying again
  random_sleep 50 70

  # loop forever, unless we hit a critical failure
done

handleReturn
}

main_loop || exit 1

# It's okay if exit happens before the lock is released. 
# Stale locks are automatically cleaned up when this script starts.
unlock arms &>/dev/null

